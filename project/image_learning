import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader, Dataset
from torchvision import transforms, models
from PIL import Image
import os
import numpy as np
from google.colab import drive

drive.mount('/content/drive')

# 1. ì»¤ìŠ¤í…€ ë°ì´í„°ì…‹ í´ë˜ìŠ¤ ë§Œë“¤ê¸°
class FoodDataset(Dataset):
    def __init__(self, data_dir, transform=None):
        self.data_dir = data_dir
        self.transform = transform
        self.classes = os.listdir(data_dir)
        self.class_to_idx = {cls: i for i, cls in enumerate(self.classes)}
        
        self.samples = []
        for class_name in self.classes:
            class_dir = os.path.join(data_dir, class_name)
            for img_name in os.listdir(class_dir):
                img_path = os.path.join(class_dir, img_name)
                self.samples.append((img_path, self.class_to_idx[class_name]))
    
    def __len__(self):
        return len(self.samples)
    
    def __getitem__(self, idx):
        img_path, label = self.samples[idx]
        image = Image.open(img_path).convert('RGB')
        
        if self.transform:
            image = self.transform(image)
            
        return image, label

# 2. ë°ì´í„° ì „ì²˜ë¦¬ ì •ì˜
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.RandomHorizontalFlip(),
    transforms.RandomRotation(10),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])

# 3. ìƒˆë¡œìš´ ë°ì´í„°ì…‹ ë¶ˆëŸ¬ì˜¤ê¸°
new_data_dir = '/content/drive/MyDrive/Food_allergy/image/á„€á…®á„‹á…µ/'  # ìƒˆë¡œìš´ ìŒì‹ ì´ë¯¸ì§€ê°€ ìˆëŠ” í´ë”
new_dataset = FoodDataset(new_data_dir, transform=transform)
new_dataloader = DataLoader(new_dataset, batch_size=32, shuffle=True)

# 4. ê¸°ì¡´ ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸° (ë˜ëŠ” ì—†ìœ¼ë©´ ìƒˆë¡œ ë§Œë“¤ê¸°)
try:
    # ê¸°ì¡´ ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸°
    model = torch.load('')
    print("âœ… ê¸°ì¡´ ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸° ì„±ê³µ!")
except:
    print("âŒ ê¸°ì¡´ ëª¨ë¸ì´ ì—†ì–´ìš”! ì²˜ìŒë¶€í„° í•™ìŠµì„ ì‹œì‘í• ê²Œìš”.")
    # ResNet-18 ëª¨ë¸ ë¶ˆëŸ¬ì™€ì„œ ë§ˆì§€ë§‰ ì¸µ ìˆ˜ì •í•˜ê¸°
    model = models.resnet18(pretrained=True)
    num_classes = len(new_dataset.classes)
    model.fc = nn.Linear(model.fc.in_features, num_classes)

# 5. í•™ìŠµ ì„¤ì •
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model = model.to(device)
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.0001)  # ë‚®ì€ í•™ìŠµë¥  ì‚¬ìš©

# 6. ì¶”ê°€ í•™ìŠµ í•¨ìˆ˜
def train_model(model, dataloader, criterion, optimizer, num_epochs=5):
    model.train()
    
    for epoch in range(num_epochs):
        running_loss = 0.0
        correct = 0
        total = 0
        
        for inputs, labels in dataloader:
            inputs, labels = inputs.to(device), labels.to(device)
            
            # ê¸°ìš¸ê¸° ì´ˆê¸°í™”
            optimizer.zero_grad()
            
            # ìˆœì „íŒŒ + ì—­ì „íŒŒ + ìµœì í™”
            outputs = model(inputs)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()
            
            # í†µê³„
            running_loss += loss.item()
            _, predicted = torch.max(outputs.data, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()
        
        epoch_loss = running_loss / len(dataloader)
        epoch_acc = 100 * correct / total
        print(f'ì—í­ {epoch+1}/{num_epochs} | ì†ì‹¤: {epoch_loss:.4f} | ì •í™•ë„: {epoch_acc:.2f}%')
    
    return model

# 7. ëª¨ë¸ ì¶”ê°€ í•™ìŠµ ì‹œì‘
print("ğŸš€ ì¶”ê°€ í•™ìŠµ ì‹œì‘!")
model = train_model(model, new_dataloader, criterion, optimizer)

# 8. ìƒˆë¡œìš´ ëª¨ë¸ ì €ì¥
torch.save(model, 'food_allergy_model_updated.pt')
print("âœ¨ ì¶”ê°€ í•™ìŠµ ì™„ë£Œ! ìƒˆë¡œìš´ ëª¨ë¸ì´ 'food_allergy_model_updated.pt'ë¡œ ì €ì¥ë˜ì—ˆì–´ìš”!")

# 9. ëª¨ë¸ í…ŒìŠ¤íŠ¸ (ê°„ë‹¨í•˜ê²Œ)
def test_model(model, dataloader):
    model.eval()
    correct = 0
    total = 0
    
    with torch.no_grad():
        for inputs, labels in dataloader:
            inputs, labels = inputs.to(device), labels.to(device)
            outputs = model(inputs)
            _, predicted = torch.max(outputs.data, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()
    
    accuracy = 100 * correct / total
    print(f'í…ŒìŠ¤íŠ¸ ì •í™•ë„: {accuracy:.2f}%')
    return accuracy

# í…ŒìŠ¤íŠ¸ ë°ì´í„°ë¡œë” ìƒì„± (ê°™ì€ ë°ì´í„°ë¡œ ê°„ë‹¨íˆ í…ŒìŠ¤íŠ¸)
test_model(model, new_dataloader)

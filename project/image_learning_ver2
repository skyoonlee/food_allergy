import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader, Dataset
from torchvision import transforms, models
import numpy as np
from google.colab import drive
import os
from PIL import Image

drive.mount('/content/drive')

# 1. 커스텀 데이터셋 클래스 만들기 (수정된 버전 ✨)
class FoodDataset(Dataset):
    def __init__(self, data_dir, transform=None):
        self.data_dir = data_dir
        self.transform = transform
        self.samples = []
        self.class_to_idx = {}
        idx_counter = 0

        # 모든 하위 디렉토리를 탐색하여 실제 음식 클래스를 찾아요!
        for root, dirs, files in os.walk(data_dir):
            # 현재 root 디렉토리에 파일이 있고 하위 디렉토리가 없다면
            # 이 root 디렉토리가 바로 실제 음식 클래스 폴더예요!
            if files and not dirs:
                class_name = os.path.basename(root) # 폴더 이름을 클래스 이름으로 사용
                
                if class_name not in self.class_to_idx:
                    self.class_to_idx[class_name] = idx_counter
                    idx_counter += 1
                
                for img_name in files:
                    # 이미지 파일만 추가 (예: .jpg, .png 등)
                    if img_name.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp')):
                        img_path = os.path.join(root, img_name)
                        self.samples.append((img_path, self.class_to_idx[class_name]))
        
        self.classes = list(self.class_to_idx.keys())
        print(f"✅ 총 {len(self.classes)}개의 음식 클래스를 찾았어요: {self.classes}")
    
    def __len__(self):
        return len(self.samples)
    
    def __getitem__(self, idx):
        img_path, label = self.samples[idx]
        image = Image.open(img_path).convert('RGB')
        
        if self.transform:
            image = self.transform(image)
            
        return image, label

# 2. 데이터 전처리 정의 (이 부분은 이전 코드와 동일해요!)
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.RandomHorizontalFlip(),
    transforms.RandomRotation(10),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])

# 3. 새로운 데이터셋 불러오기
# 이번엔 '김치찌개' 데이터가 포함된 전체 데이터셋 경로를 지정해요.
# /content/drive/MyDrive/Food_allergy/image/ 이 폴더 안에 구이, 찌개(김치찌개 포함), 볶음 폴더가 있어야 해요!
data_dir_with_kimchi = '/content/drive/MyDrive/Food_allergy/image/'  # 김치찌개까지 포함된 모든 음식 데이터셋 경로
full_dataset = FoodDataset(data_dir_with_kimchi, transform=transform) # FoodDataset 사용하면 모든 하위 폴더의 음식을 클래스로 잘 인식해요!
full_dataloader = DataLoader(full_dataset, batch_size=32, shuffle=True)

# 4. 기존 모델 불러오기 및 업데이트! (✨ 이 부분이 가장 중요해요! ✨)
model = None
# 여기에 1차 학습 후 저장한 모델 파일 경로를 넣어주세요!
# 예: '/content/drive/MyDrive/food_allergy_model_v1.pt'
previous_model_path = 'food_allergy_model_updated.pt' # 또는 1차 학습 후 저장했던 파일명

try:
    print(f"🔍 기존 모델 '{previous_model_path}'를 불러오는 중...")
    model = torch.load(previous_model_path)
    print("✅ 기존 모델 불러오기 성공!")
    
    # 🌟🌟 핵심 부분: 모델의 최종 분류 층(fc layer) 업데이트 🌟🌟
    # 1차 학습 모델은 김치찌개가 없었으니, 현재 (김치찌개가 포함된) 전체 클래스 개수와 다를 수 있어요.
    num_total_classes = len(full_dataset.classes) # 현재 데이터셋의 전체 클래스 개수

    if isinstance(model, models.ResNet): # 불러온 모델이 ResNet 계열인지 확인해요!
        # 기존 fc 층의 입력 특성 수는 그대로 사용하고, 출력 특성 수만 새롭게 맞춰줘요.
        # 이렇게 하면 기존에 학습된 특징 추출 부분(convolution layers)은 그대로 유지하고,
        # 새로운 클래스를 분류할 수 있도록 마지막 층만 새롭게 갈아 끼우는 효과가 있어요.
        if model.fc.out_features != num_total_classes: # 클래스 개수가 달라졌으면 업데이트!
            original_in_features = model.fc.in_features
            model.fc = nn.Linear(original_in_features, num_total_classes)
            print(f"✔️ 기존 모델의 최종 분류 층을 {model.fc.out_features}개 클래스에 맞게 새로 만들었어요!")
        else:
            print(f"👍 모델의 최종 분류 층이 이미 {num_total_classes}개 클래스에 맞춰져 있네요!")
    else:
        print("💡 주의: 불러온 모델이 ResNet이 아닌 것 같아요. 최종 분류 층 수정이 필요할 수 있습니다.")

except (FileNotFoundError, RuntimeError) as e: # 파일을 못 찾거나, torch.load 에러 시
    print(f"❌ 기존 모델 로드 중 오류 발생 또는 파일 없음: {e}. 처음부터 학습을 시작할게요.")
    # ResNet-18 모델을 불러와서 마지막 층 수정하기
    model = models.resnet18(pretrained=True)
    num_total_classes = len(full_dataset.classes)
    model.fc = nn.Linear(model.fc.in_features, num_total_classes)
    print(f"✨ 새로운 ResNet-18 모델을 만들고, 최종 분류 층을 {num_total_classes}개 클래스에 맞게 설정했어요!")
except Exception as e: # 그 외 모든 오류
    print(f"예상치 못한 모델 로드 오류 발생: {e}. 새로운 모델로 시작합니다.")
    model = models.resnet18(pretrained=True)
    num_total_classes = len(full_dataset.classes)
    model.fc = nn.Linear(model.fc.in_features, num_total_classes)
    print(f"✨ 새로운 ResNet-18 모델을 만들고, 최종 분류 층을 {num_total_classes}개 클래스에 맞게 설정했어요!")


# 5. 학습 설정 (동일)
device = torch.device("cuda" if torch.cuda_ok() else "cpu")
model = model.to(device)
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.00001)  # 아주 낮은 학습률로 파인튜닝하는 게 좋아요! (0.0001 -> 0.00001)

# 6. 추가 학습 함수 (동일)
# ...

# 7. 모델 추가 학습 시작
print("🚀 김치찌개가 포함된 전체 데이터로 추가 학습 시작!")
# new_dataloader 대신, 김치찌개까지 포함된 full_dataloader를 사용해요!
model = train_model(model, full_dataloader, criterion, optimizer, num_epochs=10) # 에폭을 좀 더 늘려줄 수도 있어요!

# 8. 새로운 모델 저장
torch.save(model, 'food_allergy_model_v2_with_kimchi.pt') # 새로운 버전으로 저장!
print("✨ 추가 학습 완료! 새로운 모델이 'food_allergy_model_v2_with_kimchi.pt'로 저장되었어요!")

# 9. 모델 테스트 (간단하게)
# ... (test_model 함수 정의) ...
test_model(model, full_dataloader) # 전체 데이터로 테스트!

# 음식 이름들 각각의 모델이 아닌 하나의 통합 모델로 접근하기 위하여 수정
# 모든 음식 카테고리를 한 번에 분류하고, 관리가 편하고, 추론시 하나의 모델만 불러오면 됨
# 카테고리 간 특징을 공유하며 학습
# 기존 러닝 모델은 FoodDataset 클래스 data_dir 바로 아래 있는 폴더들을 클래스로 인식하도록 되어 있었음
# 그 아래 세부적인 음식 이름들을 클래스로 인식하고 학습 시키기 위해 FoodDataset 클래스 수정

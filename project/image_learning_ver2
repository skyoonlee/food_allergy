import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader, Dataset
from torchvision import transforms, models
import numpy as np
from google.colab import drive
import os
from PIL import Image

drive.mount('/content/drive')

# 1. ì»¤ìŠ¤í…€ ë°ì´í„°ì…‹ í´ë˜ìŠ¤ ë§Œë“¤ê¸° (ìˆ˜ì •ëœ ë²„ì „ âœ¨)
class FoodDataset(Dataset):
    def __init__(self, data_dir, transform=None):
        self.data_dir = data_dir
        self.transform = transform
        self.samples = []
        self.class_to_idx = {}
        idx_counter = 0

        # ëª¨ë“  í•˜ìœ„ ë””ë ‰í† ë¦¬ë¥¼ íƒìƒ‰í•˜ì—¬ ì‹¤ì œ ìŒì‹ í´ë˜ìŠ¤ë¥¼ ì°¾ì•„ìš”!
        for root, dirs, files in os.walk(data_dir):
            # í˜„ì¬ root ë””ë ‰í† ë¦¬ì— íŒŒì¼ì´ ìˆê³  í•˜ìœ„ ë””ë ‰í† ë¦¬ê°€ ì—†ë‹¤ë©´
            # ì´ root ë””ë ‰í† ë¦¬ê°€ ë°”ë¡œ ì‹¤ì œ ìŒì‹ í´ë˜ìŠ¤ í´ë”ì˜ˆìš”!
            if files and not dirs:
                class_name = os.path.basename(root) # í´ë” ì´ë¦„ì„ í´ë˜ìŠ¤ ì´ë¦„ìœ¼ë¡œ ì‚¬ìš©
                
                if class_name not in self.class_to_idx:
                    self.class_to_idx[class_name] = idx_counter
                    idx_counter += 1
                
                for img_name in files:
                    # ì´ë¯¸ì§€ íŒŒì¼ë§Œ ì¶”ê°€ (ì˜ˆ: .jpg, .png ë“±)
                    if img_name.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp')):
                        img_path = os.path.join(root, img_name)
                        self.samples.append((img_path, self.class_to_idx[class_name]))
        
        self.classes = list(self.class_to_idx.keys())
        print(f"âœ… ì´ {len(self.classes)}ê°œì˜ ìŒì‹ í´ë˜ìŠ¤ë¥¼ ì°¾ì•˜ì–´ìš”: {self.classes}")
    
    def __len__(self):
        return len(self.samples)
    
    def __getitem__(self, idx):
        img_path, label = self.samples[idx]
        image = Image.open(img_path).convert('RGB')
        
        if self.transform:
            image = self.transform(image)
            
        return image, label

# 2. ë°ì´í„° ì „ì²˜ë¦¬ ì •ì˜ (ì´ ë¶€ë¶„ì€ ì´ì „ ì½”ë“œì™€ ë™ì¼í•´ìš”!)
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.RandomHorizontalFlip(),
    transforms.RandomRotation(10),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])

# 3. ìƒˆë¡œìš´ ë°ì´í„°ì…‹ ë¶ˆëŸ¬ì˜¤ê¸°
# ì´ë²ˆì—” 'ê¹€ì¹˜ì°Œê°œ' ë°ì´í„°ê°€ í¬í•¨ëœ ì „ì²´ ë°ì´í„°ì…‹ ê²½ë¡œë¥¼ ì§€ì •í•´ìš”.
# /content/drive/MyDrive/Food_allergy/image/ ì´ í´ë” ì•ˆì— êµ¬ì´, ì°Œê°œ(ê¹€ì¹˜ì°Œê°œ í¬í•¨), ë³¶ìŒ í´ë”ê°€ ìˆì–´ì•¼ í•´ìš”!
data_dir_with_kimchi = '/content/drive/MyDrive/Food_allergy/image/'  # ê¹€ì¹˜ì°Œê°œê¹Œì§€ í¬í•¨ëœ ëª¨ë“  ìŒì‹ ë°ì´í„°ì…‹ ê²½ë¡œ
full_dataset = FoodDataset(data_dir_with_kimchi, transform=transform) # FoodDataset ì‚¬ìš©í•˜ë©´ ëª¨ë“  í•˜ìœ„ í´ë”ì˜ ìŒì‹ì„ í´ë˜ìŠ¤ë¡œ ì˜ ì¸ì‹í•´ìš”!
full_dataloader = DataLoader(full_dataset, batch_size=32, shuffle=True)

# 4. ê¸°ì¡´ ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸° ë° ì—…ë°ì´íŠ¸! (âœ¨ ì´ ë¶€ë¶„ì´ ê°€ì¥ ì¤‘ìš”í•´ìš”! âœ¨)
model = None
# ì—¬ê¸°ì— 1ì°¨ í•™ìŠµ í›„ ì €ì¥í•œ ëª¨ë¸ íŒŒì¼ ê²½ë¡œë¥¼ ë„£ì–´ì£¼ì„¸ìš”!
# ì˜ˆ: '/content/drive/MyDrive/food_allergy_model_v1.pt'
previous_model_path = 'food_allergy_model_updated.pt' # ë˜ëŠ” 1ì°¨ í•™ìŠµ í›„ ì €ì¥í–ˆë˜ íŒŒì¼ëª…

try:
    print(f"ğŸ” ê¸°ì¡´ ëª¨ë¸ '{previous_model_path}'ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...")
    model = torch.load(previous_model_path)
    print("âœ… ê¸°ì¡´ ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸° ì„±ê³µ!")
    
    # ğŸŒŸğŸŒŸ í•µì‹¬ ë¶€ë¶„: ëª¨ë¸ì˜ ìµœì¢… ë¶„ë¥˜ ì¸µ(fc layer) ì—…ë°ì´íŠ¸ ğŸŒŸğŸŒŸ
    # 1ì°¨ í•™ìŠµ ëª¨ë¸ì€ ê¹€ì¹˜ì°Œê°œê°€ ì—†ì—ˆìœ¼ë‹ˆ, í˜„ì¬ (ê¹€ì¹˜ì°Œê°œê°€ í¬í•¨ëœ) ì „ì²´ í´ë˜ìŠ¤ ê°œìˆ˜ì™€ ë‹¤ë¥¼ ìˆ˜ ìˆì–´ìš”.
    num_total_classes = len(full_dataset.classes) # í˜„ì¬ ë°ì´í„°ì…‹ì˜ ì „ì²´ í´ë˜ìŠ¤ ê°œìˆ˜

    if isinstance(model, models.ResNet): # ë¶ˆëŸ¬ì˜¨ ëª¨ë¸ì´ ResNet ê³„ì—´ì¸ì§€ í™•ì¸í•´ìš”!
        # ê¸°ì¡´ fc ì¸µì˜ ì…ë ¥ íŠ¹ì„± ìˆ˜ëŠ” ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ê³ , ì¶œë ¥ íŠ¹ì„± ìˆ˜ë§Œ ìƒˆë¡­ê²Œ ë§ì¶°ì¤˜ìš”.
        # ì´ë ‡ê²Œ í•˜ë©´ ê¸°ì¡´ì— í•™ìŠµëœ íŠ¹ì§• ì¶”ì¶œ ë¶€ë¶„(convolution layers)ì€ ê·¸ëŒ€ë¡œ ìœ ì§€í•˜ê³ ,
        # ìƒˆë¡œìš´ í´ë˜ìŠ¤ë¥¼ ë¶„ë¥˜í•  ìˆ˜ ìˆë„ë¡ ë§ˆì§€ë§‰ ì¸µë§Œ ìƒˆë¡­ê²Œ ê°ˆì•„ ë¼ìš°ëŠ” íš¨ê³¼ê°€ ìˆì–´ìš”.
        if model.fc.out_features != num_total_classes: # í´ë˜ìŠ¤ ê°œìˆ˜ê°€ ë‹¬ë¼ì¡Œìœ¼ë©´ ì—…ë°ì´íŠ¸!
            original_in_features = model.fc.in_features
            model.fc = nn.Linear(original_in_features, num_total_classes)
            print(f"âœ”ï¸ ê¸°ì¡´ ëª¨ë¸ì˜ ìµœì¢… ë¶„ë¥˜ ì¸µì„ {model.fc.out_features}ê°œ í´ë˜ìŠ¤ì— ë§ê²Œ ìƒˆë¡œ ë§Œë“¤ì—ˆì–´ìš”!")
        else:
            print(f"ğŸ‘ ëª¨ë¸ì˜ ìµœì¢… ë¶„ë¥˜ ì¸µì´ ì´ë¯¸ {num_total_classes}ê°œ í´ë˜ìŠ¤ì— ë§ì¶°ì ¸ ìˆë„¤ìš”!")
    else:
        print("ğŸ’¡ ì£¼ì˜: ë¶ˆëŸ¬ì˜¨ ëª¨ë¸ì´ ResNetì´ ì•„ë‹Œ ê²ƒ ê°™ì•„ìš”. ìµœì¢… ë¶„ë¥˜ ì¸µ ìˆ˜ì •ì´ í•„ìš”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")

except (FileNotFoundError, RuntimeError) as e: # íŒŒì¼ì„ ëª» ì°¾ê±°ë‚˜, torch.load ì—ëŸ¬ ì‹œ
    print(f"âŒ ê¸°ì¡´ ëª¨ë¸ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ ë˜ëŠ” íŒŒì¼ ì—†ìŒ: {e}. ì²˜ìŒë¶€í„° í•™ìŠµì„ ì‹œì‘í• ê²Œìš”.")
    # ResNet-18 ëª¨ë¸ì„ ë¶ˆëŸ¬ì™€ì„œ ë§ˆì§€ë§‰ ì¸µ ìˆ˜ì •í•˜ê¸°
    model = models.resnet18(pretrained=True)
    num_total_classes = len(full_dataset.classes)
    model.fc = nn.Linear(model.fc.in_features, num_total_classes)
    print(f"âœ¨ ìƒˆë¡œìš´ ResNet-18 ëª¨ë¸ì„ ë§Œë“¤ê³ , ìµœì¢… ë¶„ë¥˜ ì¸µì„ {num_total_classes}ê°œ í´ë˜ìŠ¤ì— ë§ê²Œ ì„¤ì •í–ˆì–´ìš”!")
except Exception as e: # ê·¸ ì™¸ ëª¨ë“  ì˜¤ë¥˜
    print(f"ì˜ˆìƒì¹˜ ëª»í•œ ëª¨ë¸ ë¡œë“œ ì˜¤ë¥˜ ë°œìƒ: {e}. ìƒˆë¡œìš´ ëª¨ë¸ë¡œ ì‹œì‘í•©ë‹ˆë‹¤.")
    model = models.resnet18(pretrained=True)
    num_total_classes = len(full_dataset.classes)
    model.fc = nn.Linear(model.fc.in_features, num_total_classes)
    print(f"âœ¨ ìƒˆë¡œìš´ ResNet-18 ëª¨ë¸ì„ ë§Œë“¤ê³ , ìµœì¢… ë¶„ë¥˜ ì¸µì„ {num_total_classes}ê°œ í´ë˜ìŠ¤ì— ë§ê²Œ ì„¤ì •í–ˆì–´ìš”!")


# 5. í•™ìŠµ ì„¤ì • (ë™ì¼)
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model = model.to(device)
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.00001)  # ì•„ì£¼ ë‚®ì€ í•™ìŠµë¥ ë¡œ íŒŒì¸íŠœë‹

# 6. ì¶”ê°€ í•™ìŠµ í•¨ìˆ˜ (ë™ì¼)
def train_model(model, dataloader, criterion, optimizer, num_epochs=5):
    model.train()
    
    for epoch in range(num_epochs):
        running_loss = 0.0
        correct = 0
        total = 0
        
        for inputs, labels in dataloader:
            inputs, labels = inputs.to(device), labels.to(device)
            
            # ê¸°ìš¸ê¸° ì´ˆê¸°í™”
            optimizer.zero_grad()
            
            # ìˆœì „íŒŒ + ì—­ì „íŒŒ + ìµœì í™”
            outputs = model(inputs)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()
            
            # í†µê³„
            running_loss += loss.item()
            _, predicted = torch.max(outputs.data, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()
        
        epoch_loss = running_loss / len(dataloader)
        epoch_acc = 100 * correct / total
        print(f'ì—í­ {epoch+1}/{num_epochs} | ì†ì‹¤: {epoch_loss:.4f} | ì •í™•ë„: {epoch_acc:.2f}%')
    
    return model

# 7. ëª¨ë¸ ì¶”ê°€ í•™ìŠµ ì‹œì‘
print("ğŸš€ ê¹€ì¹˜ì°Œê°œê°€ í¬í•¨ëœ ì „ì²´ ë°ì´í„°ë¡œ ì¶”ê°€ í•™ìŠµ ì‹œì‘!")
# new_dataloader ëŒ€ì‹ , ê¹€ì¹˜ì°Œê°œê¹Œì§€ í¬í•¨ëœ full_dataloaderë¥¼ ì‚¬ìš©í•´ìš”!
model = train_model(model, full_dataloader, criterion, optimizer, num_epochs=10) # ì—í­ì„ ì¢€ ë” ëŠ˜ë ¤ì¤„ ìˆ˜ë„ ìˆì–´ìš”!

# 8. ìƒˆë¡œìš´ ëª¨ë¸ ì €ì¥
torch.save(model, 'food_allergy_model_v2_with_kimchi.pt') # ìƒˆë¡œìš´ ë²„ì „ìœ¼ë¡œ ì €ì¥!
print("âœ¨ ì¶”ê°€ í•™ìŠµ ì™„ë£Œ! ìƒˆë¡œìš´ ëª¨ë¸ì´ 'food_allergy_model_v2_with_kimchi.pt'ë¡œ ì €ì¥ë˜ì—ˆì–´ìš”!")

# 9. ëª¨ë¸ í…ŒìŠ¤íŠ¸ (ê°„ë‹¨í•˜ê²Œ)
def test_model(model, dataloader):
    model.eval()
    correct = 0
    total = 0
    
    with torch.no_grad():
        for inputs, labels in dataloader:
            inputs, labels = inputs.to(device), labels.to(device)
            outputs = model(inputs)
            _, predicted = torch.max(outputs.data, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()
    
    accuracy = 100 * correct / total
    print(f'í…ŒìŠ¤íŠ¸ ì •í™•ë„: {accuracy:.2f}%')
    return accuracy

test_model(model, full_dataloader) # ì „ì²´ ë°ì´í„°ë¡œ í…ŒìŠ¤íŠ¸!
###
# 10. í´ë˜ìŠ¤ë³„ ì •í™•ë„ í™•ì¸í•˜ê¸°
def test_model_per_class(model, dataloader, classes):
    model.eval()
    class_correct = [0] * len(classes)
    class_total = [0] * len(classes)
    
    with torch.no_grad():
        for inputs, labels in dataloader:
            inputs, labels = inputs.to(device), labels.to(device)
            outputs = model(inputs)
            _, predicted = torch.max(outputs.data, 1)
            
            # í´ë˜ìŠ¤ë³„ ì •í™•ë„ ê³„ì‚°
            for i in range(len(labels)):
                label = labels[i]
                class_total[label] += 1
                if predicted[i] == label:
                    class_correct[label] += 1
    
    # í´ë˜ìŠ¤ë³„ ì •í™•ë„ ì¶œë ¥
    print("\nğŸ½ï¸ ìŒì‹ ì¢…ë¥˜ë³„ ì •í™•ë„:")
    for i in range(len(classes)):
        if class_total[i] > 0:  # ë°ì´í„°ê°€ ìˆëŠ” í´ë˜ìŠ¤ë§Œ
            accuracy = 100 * class_correct[i] / class_total[i]
            print(f'- {classes[i]}: {accuracy:.2f}% ({class_correct[i]}/{class_total[i]})')
        else:
            print(f'- {classes[i]}: í…ŒìŠ¤íŠ¸ ë°ì´í„° ì—†ìŒ')
    
    return class_correct, class_total

# í´ë˜ìŠ¤ë³„ ì •í™•ë„ í™•ì¸
class_correct, class_total = test_model_per_class(model, full_dataloader, full_dataset.classes)

# 11. ëª¨ë¸ ì‚¬ìš© ì˜ˆì‹œ (ìƒˆ ì´ë¯¸ì§€ë¡œ ì˜ˆì¸¡í•˜ê¸°)
def predict_food(model, image_path, transform, classes):
    model.eval()
    
    # ì´ë¯¸ì§€ ë¶ˆëŸ¬ì˜¤ê¸° ë° ì „ì²˜ë¦¬
    image = Image.open(image_path).convert('RGB')
    image = transform(image).unsqueeze(0).to(device)  # ë°°ì¹˜ ì°¨ì› ì¶”ê°€
    
    # ì˜ˆì¸¡
    with torch.no_grad():
        outputs = model(image)
        _, predicted = torch.max(outputs, 1)
        
        # í™•ë¥  ê³„ì‚° (ì†Œí”„íŠ¸ë§¥ìŠ¤)
        probs = torch.nn.functional.softmax(outputs, dim=1)[0]
        confidence = probs[predicted.item()].item() * 100
        
    predicted_class = classes[predicted.item()]
    
    print(f"\nğŸ”® ì˜ˆì¸¡ ê²°ê³¼: '{predicted_class}' (í™•ì‹ ë„: {confidence:.2f}%)")
    
    # ìƒìœ„ 3ê°œ ì˜ˆì¸¡ ê²°ê³¼ ë³´ì—¬ì£¼ê¸°
    top3_prob, top3_idx = torch.topk(probs, 3)
    print("ìƒìœ„ 3ê°œ ì˜ˆì¸¡:")
    for i in range(3):
        print(f"- {classes[top3_idx[i]]}: {top3_prob[i]*100:.2f}%")
    
    return predicted_class, confidence
###
# ì˜ˆì‹œ: ìƒˆë¡œìš´ ì´ë¯¸ì§€ë¡œ ì˜ˆì¸¡í•´ë³´ê¸°
# ì‹¤ì œ í…ŒìŠ¤íŠ¸í•  ì´ë¯¸ì§€ ê²½ë¡œë¥¼ ë„£ì–´ì£¼ì„¸ìš”!
# test_image_path = '/content/drive/MyDrive/Food_allergy/test_images/kimchi_stew_test.jpg'
# predict_food(model, test_image_path, transform, full_dataset.classes)

# ìŒì‹ ì´ë¦„ë“¤ ê°ê°ì˜ ëª¨ë¸ì´ ì•„ë‹Œ í•˜ë‚˜ì˜ í†µí•© ëª¨ë¸ë¡œ ì ‘ê·¼í•˜ê¸° ìœ„í•˜ì—¬ ìˆ˜ì •
# ëª¨ë“  ìŒì‹ ì¹´í…Œê³ ë¦¬ë¥¼ í•œ ë²ˆì— ë¶„ë¥˜í•˜ê³ , ê´€ë¦¬ê°€ í¸í•˜ê³ , ì¶”ë¡ ì‹œ í•˜ë‚˜ì˜ ëª¨ë¸ë§Œ ë¶ˆëŸ¬ì˜¤ë©´ ë¨
# ì¹´í…Œê³ ë¦¬ ê°„ íŠ¹ì§•ì„ ê³µìœ í•˜ë©° í•™ìŠµ
# ê¸°ì¡´ ëŸ¬ë‹ ëª¨ë¸ì€ FoodDataset í´ë˜ìŠ¤ data_dir ë°”ë¡œ ì•„ë˜ ìˆëŠ” í´ë”ë“¤ì„ í´ë˜ìŠ¤ë¡œ ì¸ì‹í•˜ë„ë¡ ë˜ì–´ ìˆì—ˆìŒ
# ê·¸ ì•„ë˜ ì„¸ë¶€ì ì¸ ìŒì‹ ì´ë¦„ë“¤ì„ í´ë˜ìŠ¤ë¡œ ì¸ì‹í•˜ê³  í•™ìŠµ ì‹œí‚¤ê¸° ìœ„í•´ FoodDataset í´ë˜ìŠ¤ ìˆ˜ì •

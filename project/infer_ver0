import matplotlib.pyplot as plt
from torchvision.models.resnet import ResNet
from torch.nn.modules.conv import Conv2d
from torch.nn.modules.batchnorm import BatchNorm2d
from torch.nn.modules.activation import ReLU
from torch.nn.modules.pooling import MaxPool2d
from torch.nn.modules.container import Sequential

torch.serialization.add_safe_globals([
    Conv2d, BatchNorm2d, ReLU, MaxPool2d, ResNet, Sequential
])

# 1. ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸°
def load_model(model_path):
    try:
        print(f"ğŸ” ëª¨ë¸ '{model_path}'ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...")
        model = torch.load(model_path, map_location=torch.device('cpu'))
        model.eval()  # í‰ê°€ ëª¨ë“œë¡œ ì„¤ì •
        print("âœ… ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸° ì„±ê³µ!")
        return model
    except Exception as e:
        print(f"âŒ ëª¨ë¸ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        return None

# 2. ì´ë¯¸ì§€ ì „ì²˜ë¦¬ í•¨ìˆ˜
def preprocess_image(image_path):
    transform = transforms.Compose([
        transforms.Resize((224, 224)),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    ])
    
    image = Image.open(image_path).convert('RGB')
    image_tensor = transform(image).unsqueeze(0)  # ë°°ì¹˜ ì°¨ì› ì¶”ê°€
    return image, image_tensor

# 3. ì´ë¯¸ì§€ ì˜ˆì¸¡ í•¨ìˆ˜
def predict_image(model, image_tensor, classes):
    # ëª¨ë¸ì´ GPUì— ìˆìœ¼ë©´ ì´ë¯¸ì§€ë„ GPUë¡œ ì´ë™
    device = next(model.parameters()).device
    image_tensor = image_tensor.to(device)
    
    with torch.no_grad():
        outputs = model(image_tensor)
        probabilities = torch.nn.functional.softmax(outputs, dim=1)[0]
        
        # ìƒìœ„ 3ê°œ ì˜ˆì¸¡ ê²°ê³¼ ê°€ì ¸ì˜¤ê¸°
        top3_prob, top3_idx = torch.topk(probabilities, 3)
        
        # ìµœì¢… ì˜ˆì¸¡ ê²°ê³¼
        predicted_idx = top3_idx[0].item()
        confidence = top3_prob[0].item() * 100
        
    return {
        'predicted_class': classes[predicted_idx],
        'confidence': confidence,
        'top3_predictions': [(classes[idx.item()], prob.item() * 100) for idx, prob in zip(top3_idx, top3_prob)]
    }

# 4. ê²°ê³¼ ì‹œê°í™” í•¨ìˆ˜ (ê·¸ë˜í”„ë¡œ ì˜ˆì˜ê²Œ ë³´ì—¬ì¤Œ)
def visualize_prediction(image, prediction_results):
    plt.figure(figsize=(12, 5))
    
    # ì›ë³¸ ì´ë¯¸ì§€ í‘œì‹œ
    plt.subplot(1, 2, 1)
    plt.imshow(image)
    plt.title("ì…ë ¥ ì´ë¯¸ì§€")
    plt.axis('off')
    
    # ì˜ˆì¸¡ ê²°ê³¼ í‘œì‹œ
    plt.subplot(1, 2, 2)
    
    classes = [p[0] for p in prediction_results['top3_predictions']]
    confidences = [p[1] for p in prediction_results['top3_predictions']]
    
    bars = plt.barh(classes, confidences, color=['gold', 'silver', 'brown'])
    plt.xlim(0, 100)
    plt.xlabel('í™•ë¥  (%)')
    plt.title(f"ì˜ˆì¸¡ ê²°ê³¼: {prediction_results['predicted_class']} ({prediction_results['confidence']:.2f}%)")
    
    # ë°” ìœ„ì— í™•ë¥ ê°’ í‘œì‹œ
    for bar, conf in zip(bars, confidences):
        plt.text(bar.get_width() + 1, bar.get_y() + bar.get_height()/2, f"{conf:.2f}%", 
                 va='center', fontsize=10)
    
    plt.tight_layout()
    plt.show()

# 5. ë©”ì¸ í•¨ìˆ˜: ì´ë¯¸ì§€ í…ŒìŠ¤íŠ¸
def test_food_image(model_path, image_path):
    # ëª¨ë¸ ê²½ë¡œ ì„¤ì •
    if model_path is None:
        model_path = "food_allergy_model_test_20250929_1456.pt"
    
    # ì´ë¯¸ì§€ ê²½ë¡œê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ í…ŒìŠ¤íŠ¸ ì´ë¯¸ì§€ ì‚¬ìš©
    if image_path is None:
        # ì‚¬ìš©ìë³„ ì—…ë¡œë“œ ê²½ë¡œ ì„¤ì •
        upload_path = set_image_path(user_id, "food")
        image_path = f"{upload_path}test_food.jpg"
        print(f"âš ï¸ ì´ë¯¸ì§€ ê²½ë¡œê°€ ì§€ì •ë˜ì§€ ì•Šì•„ ê¸°ë³¸ í…ŒìŠ¤íŠ¸ ì´ë¯¸ì§€ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤: {image_path}")
    
    # ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸°
    model = torch.load("food_allergy_model_test_20250929_1456.pt", weights_only=False)
    if model is None:
        return
    
    # í´ë˜ìŠ¤ ì´ë¦„ ê°€ì ¸ì˜¤ê¸° (ëª¨ë¸ì— ì €ì¥ëœ ê²½ìš°)
    classes = []
    if hasattr(model, 'classes'):
        classes = model.classes
    else:
        # ëª¨ë¸ì— í´ë˜ìŠ¤ ì •ë³´ê°€ ì—†ëŠ” ê²½ìš°, ì—¬ê¸°ì— ì§ì ‘ í´ë˜ìŠ¤ ì´ë¦„ ì…ë ¥
        # ëŒ€ì¥ë‹˜ì´ í•™ìŠµì‹œí‚¨ ìŒì‹ í´ë˜ìŠ¤ ì´ë¦„ì„ ë„£ì–´ì£¼ì„¸ìš”!
        classes = ["ê¹€ì¹˜ì°Œê°œ", "ëœì¥ì°Œê°œ", "ë¶ˆê³ ê¸°", "ë¹„ë¹”ë°¥", "ìˆœë‘ë¶€ì°Œê°œ"]  # ì˜ˆì‹œ í´ë˜ìŠ¤
        print(f"ëª¨ë¸ì— í´ë˜ìŠ¤ ì •ë³´ê°€ ì—†ì–´ì„œ ê¸°ë³¸ê°’ì„ ì‚¬ìš©í•©ë‹ˆë‹¤: {classes}")
    
    # ì´ë¯¸ì§€ ì „ì²˜ë¦¬
    image, image_tensor = preprocess_image(image_path)
    
    # ì˜ˆì¸¡
    prediction_results = predict_image(model, image_tensor, classes)
    
    # ê²°ê³¼ ì¶œë ¥
    print(f"\nğŸ”® ì˜ˆì¸¡ ê²°ê³¼: '{prediction_results['predicted_class']}' (í™•ì‹ ë„: {prediction_results['confidence']:.2f}%)")
    print("ìƒìœ„ 3ê°œ ì˜ˆì¸¡:")
    for i, (class_name, prob) in enumerate(prediction_results['top3_predictions']):
        print(f"- {i+1}ìœ„: {class_name}: {prob:.2f}%")
    
    # ê²°ê³¼ ì‹œê°í™”
    visualize_prediction(image, prediction_results)
    
    return prediction_results

def set_image_path(user_id=None, image_type=None):
    
    # ì‚¬ìš©ìë³„ ë˜ëŠ” ì´ë¯¸ì§€ íƒ€ì…ë³„ë¡œ ê²½ë¡œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
    
    # Args:
    #     user_id (str): ì‚¬ìš©ì ID (ì—†ìœ¼ë©´ ê¸°ë³¸ ê²½ë¡œ ì‚¬ìš©)
    #     image_type (str): ì´ë¯¸ì§€ ìœ í˜• (ì˜ˆ: "food", "allergy" ë“±)
    
    # Returns:
    #     str: ì €ì¥ ê²½ë¡œ
  
    # ê¸°ë³¸ ê²½ë¡œ ì„¤ì •
    base_path = "uploads/image"
    
    # ì‚¬ìš©ìë³„ í´ë” ìƒì„±
    if user_id:
        user_path = f"{base_path}{user_id}/"
    else:
        user_path = base_path
    
    # ì´ë¯¸ì§€ íƒ€ì…ë³„ í•˜ìœ„ í´ë” ìƒì„±
    if image_type:
        final_path = f"{user_path}{image_type}/"
    else:
        final_path = user_path
    
    # ê²½ë¡œê°€ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ ìƒì„±
    import os
    os.makedirs(final_path, exist_ok=True)
    
    return final_path

test_food_image(
    model_path="food_allergy_model_test_20250929_1456.pt",
    image_path=r"C:\Users\KCCISTC\Desktop\workspace\food_allergy\test\ë‚˜ë¬¼\ë‚˜ë¬¼\ê°€ì§€ë³¶ìŒ\Img_040_0067.jpg"
)
